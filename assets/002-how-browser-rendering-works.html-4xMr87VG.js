import{_ as s,r as o,o as r,c as l,a as e,d as n,b as a,e as i}from"./app-vkLD9k8b.js";const p="/blog/assets/image/frontend/browser/002/1-webkitflow.png",c="/blog/assets/image/frontend/browser/002/2-dom-tree.png",d="/blog/assets/image/frontend/browser/002/3-html-parse.png",g="/blog/assets/image/frontend/browser/002/4-css-parse.png",m="/blog/assets/image/frontend/browser/002/5-render-tree.png",h={},u=i('<p>浏览器渲染主要是依靠浏览器内核也就是浏览器渲染引擎，它通过一系列的解析将 HTML 文档渲染在浏览器上。</p><h2 id="主要流程" tabindex="-1"><a class="header-anchor" href="#主要流程"><span>主要流程</span></a></h2><p>渲染引擎会从网络层中获取将要渲染的文档，主要的工作流程如下：</p><figure><img src="'+p+`" alt="webkit-flow" tabindex="0" loading="lazy"><figcaption>webkit-flow</figcaption></figure><ol><li>首先浏览器会解析 HTML 文档，将 HTML 解析成 DOM 树；CSS 样式表也会在同时进行加载，生成样式规则；而 JavaScript 会通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 Style Rules。</li><li>解析完成后，渲染引擎会通过 DOM Tree 和 Style Rules 创造 Render Tree，此时会计算各个 DOM 在浏览器上的具体坐标。</li><li>最后渲染引擎遍历整个 Render Tree，由 UI 后端层绘制。</li></ol><p>整个渲染过程一个渐进的过程。为了更好的用户体验，渲染引擎将尽快在屏幕上显示内容。在开始构件和渲染 Render Tree 之前，它不会等到所有 HTML 都被解析。在部分内容被渲染的同时，渲染引擎会继续向服务器请求剩下的内容。</p><h2 id="html-解析器" tabindex="-1"><a class="header-anchor" href="#html-解析器"><span>HTML 解析器</span></a></h2><p>HTML 解析器的作用是将 HTML 解析成 DOM 树：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
      Hello World
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>example.png<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+c+'" alt="dom tree" tabindex="0" loading="lazy"><figcaption>dom tree</figcaption></figure><p>HTML 解析算法包括两个阶段：</p><ol><li>标记化：词法分析，将输入解析为标记。HTML 标记包括开始标记、结束标记、属性名称和属性值。标记器识别 token，将它传递给树构造器，然后接受下一个字符以识别下一个标记，直到输入的结束。</li><li>树构建：构建成 DOM 树。</li></ol><figure><img src="'+d+'" alt="HTML 解析" tabindex="0" loading="lazy"><figcaption>HTML 解析</figcaption></figure><h2 id="css-解析器" tabindex="-1"><a class="header-anchor" href="#css-解析器"><span>CSS 解析器</span></a></h2><p>解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><figure><img src="'+g+'" alt="css 解析器" tabindex="0" loading="lazy"><figcaption>css 解析器</figcaption></figure><h2 id="render-tree" tabindex="-1"><a class="header-anchor" href="#render-tree"><span>Render Tree</span></a></h2><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p><p>Render Tree 和 DOM Tree 并不是一一对应的，非可视化的 DOM 元素不会插入呈现树中，例如 <code>head</code> 元素。如果元素的 <code>display</code> 属性值为 <code>none</code>，那么也不会显示在呈现树中（但是 <code>visibility</code> 属性值为 <code>hidden</code> 的元素仍会显示）。</p><figure><img src="'+m+'" alt="render tree" tabindex="0" loading="lazy"><figcaption>render tree</figcaption></figure><p>接下来浏览器需要做的就是计算样式，将每一个 Render 对象的可视化属性计算（根据一系列规则，如层叠性、选择器权重等）出来，但是在这个过程中，并不包含位置和大小信息。计算这些值的过程叫做布局或回流。</p><blockquote><p>关于回流和重绘在后面说。</p></blockquote><p>总之，到目前为止，渲染引擎已经经历了一系列的工作，可以将页面展示到浏览器上了。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2>',24),b={href:"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets",target:"_blank",rel:"noopener noreferrer"},k={href:"https://coolshell.cn/articles/9666.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://zh.wiki.hancel.org/wiki/JavaScript%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zh.m.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},_={href:"https://cloud.tencent.com/developer/article/1679313",target:"_blank",rel:"noopener noreferrer"};function v(T,M){const t=o("ExternalLinkIcon");return r(),l("div",null,[u,e("ol",null,[e("li",null,[e("a",b,[n("How Browsers Work: Behind the scenes of modern web browsers - HTML5 Rocks"),a(t)])]),e("li",null,[e("a",k,[n("浏览器的渲染原理简介"),a(t)])]),e("li",null,[e("a",w,[n("JavaScript引擎 - 维基百科"),a(t)])]),e("li",null,[e("a",f,[n("浏览器引擎 - 维基百科"),a(t)])]),e("li",null,[e("a",_,[n("浏览器内核及分类 - 腾讯云社区"),a(t)])])])])}const y=s(h,[["render",v],["__file","002-how-browser-rendering-works.html.vue"]]),H=JSON.parse('{"path":"/frontend/browser/002-how-browser-rendering-works.html","title":"浏览器渲染原理","lang":"zh-CN","frontmatter":{"title":"浏览器渲染原理","date":"2021-12-16T00:00:00.000Z","category":["浏览器"],"tag":["浏览器渲染"],"description":"浏览器渲染主要是依靠浏览器内核也就是浏览器渲染引擎，它通过一系列的解析将 HTML 文档渲染在浏览器上。 主要流程 渲染引擎会从网络层中获取将要渲染的文档，主要的工作流程如下： webkit-flowwebkit-flow 首先浏览器会解析 HTML 文档，将 HTML 解析成 DOM 树；CSS 样式表也会在同时进行加载，生成样式规则；而 JavaS...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/browser/002-how-browser-rendering-works.html"}],["meta",{"property":"og:title","content":"浏览器渲染原理"}],["meta",{"property":"og:description","content":"浏览器渲染主要是依靠浏览器内核也就是浏览器渲染引擎，它通过一系列的解析将 HTML 文档渲染在浏览器上。 主要流程 渲染引擎会从网络层中获取将要渲染的文档，主要的工作流程如下： webkit-flowwebkit-flow 首先浏览器会解析 HTML 文档，将 HTML 解析成 DOM 树；CSS 样式表也会在同时进行加载，生成样式规则；而 JavaS..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://dribble-njr.github.io/blog/blog/assets/image/frontend/browser/002/1-webkitflow.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-25T10:47:40.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"浏览器渲染原理"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"浏览器渲染"}],["meta",{"property":"article:published_time","content":"2021-12-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-25T10:47:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器渲染原理\\",\\"image\\":[\\"https://dribble-njr.github.io/blog/blog/assets/image/frontend/browser/002/1-webkitflow.png\\",\\"https://dribble-njr.github.io/blog/blog/assets/image/frontend/browser/002/2-dom-tree.png\\",\\"https://dribble-njr.github.io/blog/blog/assets/image/frontend/browser/002/3-html-parse.png\\",\\"https://dribble-njr.github.io/blog/blog/assets/image/frontend/browser/002/4-css-parse.png\\",\\"https://dribble-njr.github.io/blog/blog/assets/image/frontend/browser/002/5-render-tree.png\\"],\\"datePublished\\":\\"2021-12-16T00:00:00.000Z\\",\\"dateModified\\":\\"2023-03-25T10:47:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 主要流程","slug":"主要流程","link":"#主要流程","children":[]},{"level":2,"title":"2 HTML 解析器","slug":"html-解析器","link":"#html-解析器","children":[]},{"level":2,"title":"3 CSS 解析器","slug":"css-解析器","link":"#css-解析器","children":[]},{"level":2,"title":"4 Render Tree","slug":"render-tree","link":"#render-tree","children":[]},{"level":2,"title":"5 参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1677733227000,"updatedTime":1679741260000,"contributors":[{"name":"Stephen-wzw","email":"wzw15292257101@163.com","commits":2},{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":1}]},"readingTime":{"minutes":2.95,"words":885},"filePathRelative":"frontend/browser/002-how-browser-rendering-works.md","localizedDate":"2021年12月16日","excerpt":"","autoDesc":true}');export{y as comp,H as data};
