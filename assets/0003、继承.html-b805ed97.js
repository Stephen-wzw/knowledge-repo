const e=JSON.parse('{"key":"v-21274519","path":"/frontend/basic/javascript/0003%E3%80%81%E7%BB%A7%E6%89%BF.html","title":"JavaScript 类（二）———— 继承","lang":"zh-CN","frontmatter":{"title":"JavaScript 类（二）———— 继承","date":"2022-08-25T00:00:00.000Z","category":["JavaScript"],"tag":["面向对象"],"description":"原型链 原型链是 ECMAScript 中的主要继承方式，当原型是另一个对象的实例时，那么这个原型的实例就指向了另一个原型，这样实例和原型就组成了一条原型链。 使用原型链实现继承可以继承父类的属性和方法，然而它还有自己的弊端。 盗用构造函数 为了解决原型链继承问题，可以使用“盗用构造函数”。基本思路很简单：在子类构造函数中调用父类构造函数。可以使用 a...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/frontend/basic/javascript/0003%E3%80%81%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"My Konwledge Base"}],["meta",{"property":"og:title","content":"JavaScript 类（二）———— 继承"}],["meta",{"property":"og:description","content":"原型链 原型链是 ECMAScript 中的主要继承方式，当原型是另一个对象的实例时，那么这个原型的实例就指向了另一个原型，这样实例和原型就组成了一条原型链。 使用原型链实现继承可以继承父类的属性和方法，然而它还有自己的弊端。 盗用构造函数 为了解决原型链继承问题，可以使用“盗用构造函数”。基本思路很简单：在子类构造函数中调用父类构造函数。可以使用 a..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-25T10:47:40.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2022-08-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-25T10:47:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript 类（二）———— 继承\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-08-25T00:00:00.000Z\\",\\"dateModified\\":\\"2023-03-25T10:47:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"原型链","slug":"原型链","link":"#原型链","children":[]},{"level":2,"title":"盗用构造函数","slug":"盗用构造函数","link":"#盗用构造函数","children":[]},{"level":2,"title":"组合继承","slug":"组合继承","link":"#组合继承","children":[]},{"level":2,"title":"寄生式组合继承","slug":"寄生式组合继承","link":"#寄生式组合继承","children":[{"level":3,"title":"原型式继承","slug":"原型式继承","link":"#原型式继承","children":[]},{"level":3,"title":"寄生式继承","slug":"寄生式继承","link":"#寄生式继承","children":[]},{"level":3,"title":"寄生式组合继承","slug":"寄生式组合继承-1","link":"#寄生式组合继承-1","children":[]}]}],"git":{"createdTime":1677733227000,"updatedTime":1679741260000,"contributors":[{"name":"Stephen-wzw","email":"wzw15292257101@163.com","commits":1},{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":1}]},"readingTime":{"minutes":7,"words":2101},"filePathRelative":"frontend/basic/javascript/0003、继承.md","localizedDate":"2022年8月25日","excerpt":"","autoDesc":true}');export{e as data};
